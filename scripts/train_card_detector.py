#!/usr/bin/env python3
"""CLI script for training the YOLOv8 card detector.

This script trains a YOLOv8 model for card detection using synthetic
training data generated by Phase 1.

Usage:
    # Train with default configuration
    uv run python scripts/train_card_detector.py \\
        --data-yaml data/training/data.yaml

    # Train with custom config file
    uv run python scripts/train_card_detector.py \\
        --config configs/yolo_training.yaml

    # Train with mobile-optimized settings
    uv run python scripts/train_card_detector.py \\
        --data-yaml data/training/data.yaml \\
        --variant n \\
        --epochs 100

    # Resume training from checkpoint
    uv run python scripts/train_card_detector.py \\
        --resume runs/detect/train/weights/last.pt

Requirements:
    Install recognition extras: uv sync --extra recognition
"""

import argparse
import logging
import sys
from pathlib import Path

import yaml

# Add project root to path for imports
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT))


def setup_logging(verbose: bool = False) -> None:
    """Configure logging for the script.

    Args:
        verbose: If True, use DEBUG level; otherwise INFO.
    """
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=level,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
    )


def load_config(config_path: Path) -> dict:
    """Load configuration from YAML file.

    Args:
        config_path: Path to configuration file.

    Returns:
        Configuration dictionary.
    """
    with open(config_path) as f:
        return yaml.safe_load(f)


def train_model(
    data_yaml: Path,
    variant: str = "s",
    pretrained: str | None = None,
    epochs: int = 100,
    batch_size: int = 16,
    image_size: int = 640,
    patience: int = 20,
    device: str = "",
    workers: int = 8,
    cache: bool = False,
    amp: bool = True,
    resume: str | None = None,
    project: str = "card_detector",
    name: str = "",
    freeze_epochs: int = 10,
    save_period: int = 10,
    hsv_h: float = 0.015,
    hsv_s: float = 0.7,
    hsv_v: float = 0.4,
    mosaic: float = 0.5,
    mixup: float = 0.1,
    output_dir: Path | None = None,
) -> Path:
    """Train the YOLOv8 card detector.

    Args:
        data_yaml: Path to YOLO data.yaml file.
        variant: YOLOv8 variant (n, s, m, l, x).
        pretrained: Path to pretrained weights or model name.
        epochs: Number of training epochs.
        batch_size: Training batch size.
        image_size: Input image size.
        patience: Early stopping patience.
        device: Training device.
        workers: Number of data loader workers.
        cache: Cache images in RAM/disk.
        amp: Enable automatic mixed precision.
        resume: Path to checkpoint to resume from.
        project: Project name for logging.
        name: Experiment name for logging.
        freeze_epochs: Epochs to freeze backbone.
        save_period: Save checkpoint every N epochs.
        hsv_h: HSV hue augmentation.
        hsv_s: HSV saturation augmentation.
        hsv_v: HSV value augmentation.
        mosaic: Mosaic augmentation probability.
        mixup: MixUp augmentation probability.
        output_dir: Output directory for training runs.

    Returns:
        Path to the best model weights.

    Raises:
        ImportError: If ultralytics is not installed.
        FileNotFoundError: If data.yaml doesn't exist.
    """
    try:
        from ultralytics import YOLO
    except ImportError as e:
        raise ImportError(
            "ultralytics is required for training. "
            "Install with: uv sync --extra recognition"
        ) from e

    logger = logging.getLogger(__name__)

    # Validate data.yaml
    if not data_yaml.exists():
        raise FileNotFoundError(
            f"data.yaml not found: {data_yaml}\n"
            "Generate training data first with scripts/generate_training_data.py"
        )

    # Determine model weights
    if resume:
        model_path = resume
        logger.info(f"Resuming training from: {resume}")
    elif pretrained:
        model_path = pretrained
        logger.info(f"Using pretrained weights: {pretrained}")
    else:
        model_path = f"yolov8{variant}.pt"
        logger.info(f"Using default pretrained weights: {model_path}")

    # Load model
    model = YOLO(model_path)

    # Set output directory
    if output_dir:
        project_dir = output_dir / project
    else:
        project_dir = PROJECT_ROOT / "runs" / "detect" / project

    # Log training configuration
    logger.info("=" * 60)
    logger.info("TRAINING CONFIGURATION")
    logger.info("=" * 60)
    logger.info(f"Data YAML: {data_yaml}")
    logger.info(f"Model: yolov8{variant}")
    logger.info(f"Epochs: {epochs}")
    logger.info(f"Batch size: {batch_size}")
    logger.info(f"Image size: {image_size}")
    logger.info(f"Device: {device or 'auto'}")
    logger.info(f"Output: {project_dir}")
    logger.info("=" * 60)

    # Prepare training arguments
    train_args = {
        "data": str(data_yaml),
        "epochs": epochs,
        "batch": batch_size,
        "imgsz": image_size,
        "patience": patience,
        "device": device or None,
        "workers": workers,
        "cache": cache,
        "amp": amp,
        "project": str(project_dir),
        "name": name or "train",
        "exist_ok": True,
        "pretrained": True,
        "resume": bool(resume),
        "save_period": save_period,
        "plots": True,
        "val": True,
        # Augmentation settings
        "hsv_h": hsv_h,
        "hsv_s": hsv_s,
        "hsv_v": hsv_v,
        "mosaic": mosaic,
        "mixup": mixup,
        # Cards should not be flipped
        "flipud": 0.0,
        "fliplr": 0.0,
    }

    # Add freeze parameter if specified
    if freeze_epochs > 0 and not resume:
        # Freeze backbone layers for initial training
        train_args["freeze"] = freeze_epochs

    # Train model
    logger.info("Starting training...")
    results = model.train(**train_args)

    # Get best model path
    best_model_path = project_dir / (name or "train") / "weights" / "best.pt"
    logger.info(f"Training complete. Best model: {best_model_path}")

    # Log final metrics
    if hasattr(results, "results_dict"):
        logger.info("=" * 60)
        logger.info("FINAL METRICS")
        logger.info("=" * 60)
        metrics = results.results_dict
        logger.info(f"mAP@0.5: {metrics.get('metrics/mAP50(B)', 'N/A'):.4f}")
        logger.info(f"mAP@0.5:0.95: {metrics.get('metrics/mAP50-95(B)', 'N/A'):.4f}")
        logger.info(f"Precision: {metrics.get('metrics/precision(B)', 'N/A'):.4f}")
        logger.info(f"Recall: {metrics.get('metrics/recall(B)', 'N/A'):.4f}")
        logger.info("=" * 60)

    return best_model_path


def main() -> int:
    """Main entry point for the CLI.

    Returns:
        Exit code.
    """
    parser = argparse.ArgumentParser(
        description="Train YOLOv8 card detector",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__,
    )

    # Data arguments
    parser.add_argument(
        "--data-yaml",
        type=Path,
        help="Path to YOLO data.yaml file",
    )

    parser.add_argument(
        "--config",
        type=Path,
        help="Path to YAML configuration file",
    )

    # Model arguments
    parser.add_argument(
        "--variant",
        type=str,
        choices=["n", "s", "m", "l", "x"],
        default="s",
        help="YOLOv8 variant (default: s)",
    )

    parser.add_argument(
        "--pretrained",
        type=str,
        help="Path to pretrained weights",
    )

    # Training arguments
    parser.add_argument(
        "--epochs",
        type=int,
        default=100,
        help="Number of training epochs (default: 100)",
    )

    parser.add_argument(
        "--batch-size",
        type=int,
        default=16,
        help="Training batch size (default: 16)",
    )

    parser.add_argument(
        "--image-size",
        type=int,
        default=640,
        help="Input image size (default: 640)",
    )

    parser.add_argument(
        "--patience",
        type=int,
        default=20,
        help="Early stopping patience (default: 20)",
    )

    parser.add_argument(
        "--device",
        type=str,
        default="",
        help="Training device (default: auto)",
    )

    parser.add_argument(
        "--workers",
        type=int,
        default=8,
        help="Data loader workers (default: 8)",
    )

    parser.add_argument(
        "--cache",
        action="store_true",
        help="Cache images in RAM",
    )

    parser.add_argument(
        "--no-amp",
        action="store_true",
        help="Disable automatic mixed precision",
    )

    parser.add_argument(
        "--resume",
        type=str,
        help="Resume training from checkpoint",
    )

    parser.add_argument(
        "--freeze-epochs",
        type=int,
        default=10,
        help="Epochs to freeze backbone (default: 10)",
    )

    # Output arguments
    parser.add_argument(
        "--output-dir",
        type=Path,
        help="Output directory for training runs",
    )

    parser.add_argument(
        "--project",
        type=str,
        default="card_detector",
        help="Project name (default: card_detector)",
    )

    parser.add_argument(
        "--name",
        type=str,
        default="",
        help="Experiment name (default: auto)",
    )

    # Logging arguments
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Enable verbose logging",
    )

    args = parser.parse_args()

    # Setup logging
    setup_logging(args.verbose)
    logger = logging.getLogger(__name__)

    # Load config from file if provided
    config = {}
    if args.config:
        if not args.config.exists():
            logger.error(f"Config file not found: {args.config}")
            return 1
        config = load_config(args.config)
        logger.info(f"Loaded configuration from {args.config}")

    # Get data.yaml path (CLI > config > default)
    data_yaml = args.data_yaml
    if data_yaml is None:
        paths_config = config.get("paths", {})
        data_yaml_str = paths_config.get("data_yaml", "data/training/data.yaml")
        data_yaml = PROJECT_ROOT / data_yaml_str
    data_yaml = Path(data_yaml)

    # Get training parameters (CLI > config > defaults)
    model_config = config.get("model", {})
    training_config = config.get("training", {})
    aug_config = config.get("augmentation", {})

    variant = args.variant or model_config.get("variant", "s")
    pretrained = args.pretrained or model_config.get("pretrained_weights")
    epochs = args.epochs or training_config.get("epochs", 100)
    batch_size = args.batch_size or training_config.get("batch_size", 16)
    image_size = args.image_size or model_config.get("image_size", 640)
    patience = args.patience or training_config.get("patience", 20)
    device = args.device or training_config.get("device", "")
    workers = args.workers or training_config.get("workers", 8)
    freeze_epochs = (
        args.freeze_epochs
        if args.freeze_epochs is not None
        else (training_config.get("freeze_backbone_epochs", 10))
    )

    # Augmentation parameters
    hsv_h = aug_config.get("hsv_h", 0.015)
    hsv_s = aug_config.get("hsv_s", 0.7)
    hsv_v = aug_config.get("hsv_v", 0.4)
    mosaic = aug_config.get("mosaic", 0.5)
    mixup = aug_config.get("mixup", 0.1)

    # Run training
    try:
        best_model = train_model(
            data_yaml=data_yaml,
            variant=variant,
            pretrained=pretrained,
            epochs=epochs,
            batch_size=batch_size,
            image_size=image_size,
            patience=patience,
            device=device,
            workers=workers,
            cache=args.cache,
            amp=not args.no_amp,
            resume=args.resume,
            project=args.project,
            name=args.name,
            freeze_epochs=freeze_epochs,
            output_dir=args.output_dir,
            hsv_h=hsv_h,
            hsv_s=hsv_s,
            hsv_v=hsv_v,
            mosaic=mosaic,
            mixup=mixup,
        )
        logger.info(f"Training successful. Best model saved to: {best_model}")
        return 0

    except ImportError as e:
        logger.error(str(e))
        return 1
    except FileNotFoundError as e:
        logger.error(str(e))
        return 1
    except Exception as e:
        logger.exception(f"Training failed: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
