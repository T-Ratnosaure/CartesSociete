"""Game engine for CartesSociete.

This module provides the main game loop and orchestrates all game
components including state management, actions, combat, and market.
"""

from dataclasses import dataclass, field

from src.cards.models import Card

from .abilities import (
    apply_per_turn_effects,
    resolve_bonus_text_effects,
    resolve_forgeron_abilities,
    resolve_invocateur_abilities,
    resolve_monture_abilities,
    resolve_passive_abilities,
)
from .actions import end_turn
from .combat import CombatResult, resolve_combat
from .market import (
    draw_cost5_card,
    draw_weapons,
    mix_decks,
    refresh_market,
    setup_decks,
    should_mix_decks,
    summon_demon,
)
from .state import GamePhase, PlayerState, create_initial_game_state


@dataclass
class TurnResult:
    """Result of executing a complete turn.

    Attributes:
        turn_number: The turn that was executed.
        combat_result: Result of combat resolution.
        per_turn_damage: Per-turn self-damage applied (e.g., from Mutanus).
        eliminated_players: Players eliminated this turn.
        game_over: Whether the game ended this turn.
        winner: The winning player if game is over.
        econome_po_bonus: Extra PO generated by Econome passives (per player).
        weapons_drawn: Weapons drawn by Forgeron abilities (per player).
        demons_summoned: Demons summoned by Invocateur abilities (per player).
        cost5_cards_drawn: Cost-5 cards drawn by Monture abilities (per player).
    """

    turn_number: int
    combat_result: CombatResult | None = None
    per_turn_damage: dict[int, int] = field(default_factory=dict)
    eliminated_players: list[PlayerState] = field(default_factory=list)
    game_over: bool = False
    winner: PlayerState | None = None
    econome_po_bonus: dict[int, int] = field(default_factory=dict)
    weapons_drawn: dict[int, int] = field(default_factory=dict)
    demons_summoned: dict[int, list[str]] = field(default_factory=dict)
    cost5_cards_drawn: dict[int, int] = field(default_factory=dict)


class GameEngine:
    """Main game engine that orchestrates a CartesSociete game.

    The engine manages the game loop, processes player actions,
    and handles phase transitions.

    Attributes:
        state: Current game state.
        config: Game configuration.
    """

    def __init__(
        self,
        num_players: int,
        player_names: list[str] | None = None,
        all_cards: list[Card] | None = None,
    ) -> None:
        """Initialize a new game.

        Args:
            num_players: Number of players (2-5).
            player_names: Optional list of player names.
            all_cards: Optional list of cards to use. If None, uses empty decks.
        """
        self.state = create_initial_game_state(num_players, player_names)

        # Set up decks if cards provided
        if all_cards:
            (
                self.state.cost_1_deck,
                self.state.cost_2_deck,
                self.state.cost_3_deck,
                self.state.cost_4_deck,
                self.state.cost_5_deck,
                self.state.weapon_deck,
                self.state.demon_deck,
            ) = setup_decks(all_cards)

        # Initialize first turn
        self._start_turn()

    def _start_turn(
        self,
    ) -> tuple[dict[int, int], dict[int, int], dict[int, list[str]], dict[int, int]]:
        """Initialize a new turn.

        Returns:
            Tuple of (econome_po_bonus, weapons_drawn, demons_summoned, cost5_drawn)
            dicts per player.
        """
        econome_bonuses: dict[int, int] = {}
        weapons_drawn: dict[int, int] = {}
        demons_summoned: dict[int, list[str]] = {}
        cost5_drawn: dict[int, int] = {}

        # Set base PO for all players
        base_po = self.state.get_po_for_turn()
        for player in self.state.players:
            if not player.is_alive():
                continue

            # Calculate Econome PO bonus
            passives = resolve_passive_abilities(player)
            extra_po = passives.extra_po

            # Calculate per-turn PO bonus from bonus_text effects
            bonus_text = resolve_bonus_text_effects(player, None)
            extra_po += bonus_text.per_turn_po

            player.po = base_po + extra_po

            if extra_po > 0:
                econome_bonuses[player.player_id] = extra_po

            # Forgeron weapon draw
            weapon_count = resolve_forgeron_abilities(player)
            if weapon_count > 0:
                drawn = draw_weapons(self.state, player.player_id, weapon_count)
                if drawn:
                    weapons_drawn[player.player_id] = len(drawn)

            # Invocateur demon summoning
            invocateur_result = resolve_invocateur_abilities(player)
            if invocateur_result.demons_to_summon:
                summoned_names: list[str] = []
                for demon_name in invocateur_result.demons_to_summon:
                    demon = summon_demon(self.state, player.player_id, demon_name)
                    if demon:
                        summoned_names.append(demon.name)
                if summoned_names:
                    demons_summoned[player.player_id] = summoned_names

            # Monture cost-5 card draw
            monture_result = resolve_monture_abilities(player)
            if monture_result.cards_to_draw > 0:
                cards_drawn_count = 0
                for _ in range(monture_result.cards_to_draw):
                    card = draw_cost5_card(self.state, player.player_id)
                    if card:
                        cards_drawn_count += 1
                if cards_drawn_count > 0:
                    cost5_drawn[player.player_id] = cards_drawn_count

        # Reveal market cards
        refresh_market(self.state)

        # Set phase to market
        self.state.phase = GamePhase.MARKET

        return econome_bonuses, weapons_drawn, demons_summoned, cost5_drawn

    def advance_phase(self) -> GamePhase:
        """Advance to the next game phase.

        Returns:
            The new game phase.
        """
        end_turn(self.state)
        return self.state.phase

    def execute_combat(self) -> CombatResult:
        """Execute the combat phase.

        Returns:
            Combat result with damage dealt and eliminations.
        """
        if self.state.phase != GamePhase.COMBAT:
            self.state.phase = GamePhase.COMBAT

        result = resolve_combat(self.state)
        return result

    def end_turn(self) -> TurnResult:
        """Complete the current turn and prepare for the next.

        Handles combat resolution, per-turn effects, deck mixing, and turn
        transition.

        Returns:
            TurnResult with turn outcome.
        """
        turn_number = self.state.turn

        # Resolve combat if in combat phase
        combat_result = None
        if self.state.phase == GamePhase.COMBAT:
            combat_result = self.execute_combat()

        # Move to end phase
        self.state.phase = GamePhase.END

        # Apply per-turn effects (e.g., Mutanus "Vous perdez X PV par tour")
        per_turn_damage: dict[int, int] = {}
        all_eliminations: list[PlayerState] = []

        if combat_result:
            all_eliminations = list(combat_result.eliminations)

        for player in self.state.get_alive_players():
            effects = apply_per_turn_effects(player)
            # Track net damage (self-damage minus healing)
            net_damage = effects.total_self_damage - effects.total_pv_heal
            if net_damage > 0:
                per_turn_damage[player.player_id] = net_damage
            elif net_damage < 0:
                # Negative damage = healing, store as negative for display
                per_turn_damage[player.player_id] = net_damage
            # Check for elimination from per-turn damage
            if player.health <= 0 and not player.eliminated:
                player.eliminated = True
                all_eliminations.append(player)

        # Check for game over
        if self.state.is_game_over():
            return TurnResult(
                turn_number=turn_number,
                combat_result=combat_result,
                per_turn_damage=per_turn_damage,
                eliminated_players=all_eliminations,
                game_over=True,
                winner=self.state.get_winner(),
            )

        # Handle deck mixing after even turns
        if should_mix_decks(self.state):
            mix_decks(self.state)

        # Start new turn
        self.state.turn += 1
        econome_bonuses, weapons_drawn, demons_summoned, cost5_drawn = (
            self._start_turn()
        )

        return TurnResult(
            turn_number=turn_number,
            combat_result=combat_result,
            per_turn_damage=per_turn_damage,
            eliminated_players=all_eliminations,
            game_over=False,
            econome_po_bonus=econome_bonuses,
            weapons_drawn=weapons_drawn,
            demons_summoned=demons_summoned,
            cost5_cards_drawn=cost5_drawn,
        )

    def run_turn(self) -> TurnResult:
        """Run a complete turn from start to finish.

        This method assumes no player interaction (for simulation).
        In a real game, you'd pause for player input between phases.

        Returns:
            TurnResult with turn outcome.
        """
        # Market phase (players buy cards)
        self.state.phase = GamePhase.MARKET
        # ... player actions would go here

        # Play phase (players play/replace cards)
        self.state.phase = GamePhase.PLAY
        # ... player actions would go here

        # Combat phase
        self.state.phase = GamePhase.COMBAT
        self.execute_combat()

        # End turn
        return self.end_turn()

    def simulate_game(self, max_turns: int = 100) -> PlayerState | None:
        """Simulate a complete game with random/no actions.

        This is a basic simulation that just advances turns without
        player actions. Useful for testing the game loop.

        Args:
            max_turns: Maximum turns before forcing a draw.

        Returns:
            The winning player, or None if max turns reached.
        """
        while self.state.turn <= max_turns:
            result = self.run_turn()
            if result.game_over:
                return result.winner

        return None  # Draw/timeout

    def get_legal_actions(self, player: PlayerState) -> list[str]:
        """Get a list of legal actions for a player in the current phase.

        Args:
            player: The player to check.

        Returns:
            List of action descriptions.
        """
        actions: list[str] = []

        if self.state.phase == GamePhase.MARKET:
            # Can buy affordable cards from market
            for card in self.state.market_cards:
                if card.cost is not None and card.cost <= player.po:
                    actions.append(f"buy:{card.id}")

            actions.append("end_market")

        elif self.state.phase == GamePhase.PLAY:
            # Can play cards from hand
            can_play = player.can_play_card()
            for card in player.hand:
                if can_play:
                    actions.append(f"play:{card.id}")
                # Can always replace
                for board_card in player.board:
                    actions.append(f"replace:{card.id}:{board_card.id}")

            actions.append("end_play")

        return actions

    def get_state_summary(self) -> str:
        """Get a summary of the current game state.

        Returns:
            Multi-line string describing the game state.
        """
        lines = [
            f"=== Turn {self.state.turn} - {self.state.phase.value} phase ===",
            f"Cost Tier: {self.state.get_current_cost_tier()}",
            f"PO: {self.state.get_po_for_turn()}",
            "",
            "Players:",
        ]

        for player in self.state.players:
            status = "ALIVE" if player.is_alive() else "ELIMINATED"
            lines.append(
                f"  {player.name}: {player.health} PV, "
                f"{len(player.hand)} hand, {len(player.board)} board [{status}]"
            )
            if player.board:
                total_atk = player.get_total_attack()
                total_hp = player.get_total_health()
                lines.append(f"    Board: ATK={total_atk}, HP={total_hp}")

        lines.append(f"\nMarket: {len(self.state.market_cards)} cards")

        return "\n".join(lines)
